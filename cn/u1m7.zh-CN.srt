1
00:00:02,390 --> 00:00:09,280
枚举是一种表示值可以是有限可能值集合中的一个的方式，

2
00:00:09,740 --> 00:00:12,110
例如一副扑克牌中的花色之一。

3
00:00:12,960 --> 00:00:17,760
枚举是Rust中定义自定义类型的一种方式。另一种是结构体，

4
00:00:17,770 --> 00:00:19,850
我们将在下一节介绍结构体。

5
00:00:21,690 --> 00:00:25,350
我们将使用一些在第4讲过的基本数据类型，

6
00:00:25,940 --> 00:00:27,190
我们将展示

7
00:00:27,200 --> 00:00:34,409
枚举是如何很好地与第6讲控制流时讲过的匹配表达式一起工作的。

8
00:00:34,760 --> 00:00:35,080
在本节中，首先，

9
00:00:35,080 --> 00:00:37,550
我们将多讨论一下枚举在什么情况下是有用的。

10
00:00:38,490 --> 00:00:42,010
然后，我们将了解在Rust中定义和使用枚举的语法。

11
00:00:43,240 --> 00:00:46,040
我们将看到如何定义保存数据的枚举变量，

12
00:00:46,310 --> 00:00:50,950
并通过查看与匹配表达式一起使用枚举的一些示例来结束该模块。

13
00:00:53,040 --> 00:00:55,580
让我们从一个枚举挺有用的例子开始。

14
00:00:57,240 --> 00:01:01,360
假设我们正在编写一个与冰球有关的程序。在冰球比赛中，

15
00:01:01,440 --> 00:01:02,430
球员可以打不同的位置：

16
00:01:02,430 --> 00:01:06,170
中锋、边锋、后卫或

17
00:01:06,319 --> 00:01:06,900
守门员。

18
00:01:08,840 --> 00:01:16,810
球员的这一属性有两个方面使其成为使用枚举建模的好例子。

19
00:01:16,819 --> 00:01:17,010
首先，

20
00:01:17,010 --> 00:01:22,319
玩家一次只能处于其中一个位置。虽然球员可能会改变位置，

21
00:01:22,610 --> 00:01:26,050
但他们不会同时站在球门和中锋位置。

22
00:01:28,240 --> 00:01:28,890
其次，

23
00:01:29,069 --> 00:01:32,890
我们可以列出冰球中一个位置值的所有可能性。

24
00:01:33,640 --> 00:01:35,650
可能的值是有限的，

25
00:01:35,840 --> 00:01:36,850
而且它们不会改变。

26
00:01:37,540 --> 00:01:41,650
另外我们的冰球程序不需要允许用户定义新的冰球位置。

27
00:01:43,640 --> 00:01:45,650
现在我们已经有了一个适合使用枚举的例子，

28
00:01:46,240 --> 00:01:47,280
让我们看看如何在Rust代码中定义它。

29
00:01:47,290 --> 00:01:47,940


30
00:01:49,940 --> 00:01:53,680
我们从 enum 关键字开始，然后为整个集合选择一个名称。

31
00:01:53,930 --> 00:01:54,710
在本例中，

32
00:01:54,740 --> 00:01:56,450
我们选择 HockeyPosition 作为类型名。

33
00:01:57,590 --> 00:02:01,970
然后，放入花括号和一个由逗号分隔的枚举可能具有的值列表。

34
00:02:01,970 --> 00:02:02,340


35
00:02:02,340 --> 00:02:02,560
枚举值名称

36
00:02:02,560 --> 00:02:05,150
 这些被称为枚举的枚举值。

37
00:02:06,180 --> 00:02:06,990
在本例中，

38
00:02:07,120 --> 00:02:13,250
有Center（译者注：程序变量名不翻译），Wing，Defense 和 Goalie 这几种值。枚举类型名和

39
00:02:13,250 --> 00:02:13,389
枚举值名称

40
00:02:13,389 --> 00:02:16,350
习惯上以驼峰风格命名。

41
00:02:18,210 --> 00:02:20,230
我们已经定义了一个HockeyPosition 类型变量。

42
00:02:20,350 --> 00:02:21,450
让我们来看看如何使用它！

43
00:02:23,410 --> 00:02:31,350
我们可以通过指定枚举类型名、两个冒号和变量名来设置一个变量，使其具有枚举变量之一的值。

44
00:02:32,040 --> 00:02:35,550
枚举值的名称空间位于整个枚举类型的下面。

45
00:02:37,340 --> 00:02:41,050
还可以定义一个函数，将HockeyPosition类型作为形参，

46
00:02:41,540 --> 00:02:45,550
调用该函数并将枚举的任意值传递给它。

47
00:02:47,240 --> 00:02:48,840
这个函数不做任何事情——

48
00:02:48,850 --> 00:02:50,450
我们只是展示函数签名是如何写的。

49
00:02:52,280 --> 00:02:52,870
还可以定义

50
00:02:52,870 --> 00:02:55,750
每个枚举值来保存额外的数据

51
00:02:56,740 --> 00:02:59,710
这与 Java 和 C 等语言中的枚举不同，

52
00:02:59,740 --> 00:03:01,450
它们不能保存额外的数据。

53
00:03:03,639 --> 00:03:07,950
下面是一个枚举，它表示程序支持的不同类型的时钟。

54
00:03:08,540 --> 00:03:10,900
日晷只有一个关于小时的值。

55
00:03:12,139 --> 00:03:15,550
这里写的数字时钟只有小时和分钟方面的值。

56
00:03:16,070 --> 00:03:24,350
而这里的模拟时钟拥有时针，分针和秒针的概念。

57
00:03:24,760 --> 00:03:27,470
枚举值可以保存多个数据。这里的括号类似元组。

58
00:03:27,470 --> 00:03:31,790
枚举值还可以拥有命名字段，就想结构体一样，我们将在

59
00:03:31,790 --> 00:03:33,150
下一节介绍结构体。

60
00:03:35,140 --> 00:03:35,750
最后，

61
00:03:36,210 --> 00:03:39,150
让我们看看枚举和匹配表达式是如何很好地协同工作的。

62
00:03:40,240 --> 00:03:41,750
以我们的时钟程序为例，

63
00:03:42,280 --> 00:03:44,760
让我们编写一个函数，打印出时间描述，

64
00:03:44,770 --> 00:03:46,400
不管我们有什么样的时钟。

65
00:03:47,370 --> 00:03:49,550
这个函数有一个时钟类型的参数。

66
00:03:49,550 --> 00:03:54,330
在函数中，我们将匹配同类型的时钟值，并根据不同的

67
00:03:54,340 --> 00:03:59,350
时种类型值做不同的事。在匹配表达式的每个模式中，

68
00:03:59,740 --> 00:04:02,350
我们可以解构每个枚举值持有的数据。

69
00:04:02,840 --> 00:04:03,650
例如，

70
00:04:03,660 --> 00:04:04,850
例如，在 Analog 模式中，

71
00:04:05,340 --> 00:04:07,640
我们创建了新的变量(小时、分钟和秒) ，

72
00:04:07,710 --> 00:04:14,950
它们与该变量中保存的三个 u8值相匹配。在该模式下的代码中，

73
00:04:15,340 --> 00:04:16,850
就可以使用这三个值。

74
00:04:20,839 --> 00:04:21,750
这段代码会打印，

75
00:04:22,480 --> 00:04:25,650
It is 25 minutes and 45 seconds past 9 o'clock.

76
00:04:28,100 --> 00:04:32,390
枚举对于定义可能是一组值之一的类型非常有用。

77
00:04:33,339 --> 00:04:35,250
还可以选择持有额外的数据，

78
00:04:35,640 --> 00:04:43,150
并在匹配表达式中根据匹配来做我们想做的操作，并使用模式来解构枚举值里持有的额外数据。

79
00:04:44,940 --> 00:04:45,490
下一节，

80
00:04:45,670 --> 00:04:48,370
我们将讨论定义自定义数据类型的另一种方法——结构体。

