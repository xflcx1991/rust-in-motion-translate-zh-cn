1
00:00:02,440 --> 00:00:03,579
枚举和结构体

2
00:00:03,580 --> 00:00:05,509
是我们定义构成自定义类型数据的方式。

3
00:00:05,510 --> 00:00:06,760
是我们定义构成自定义类型数据的方式。

4
00:00:07,400 --> 00:00:09,399
方法是我们定义自定义类型行为的方式。

5
00:00:09,400 --> 00:00:10,690
方法是我们定义自定义类型行为的方式。

6
00:00:12,830 --> 00:00:14,839
方法与函数类似，

7
00:00:14,840 --> 00:00:16,450
我们在第 5 讲已经介绍过函数。

8
00:00:17,560 --> 00:00:19,419
方法在枚举或结构体的上下文中定义，

9
00:00:19,420 --> 00:00:21,529
枚举在第 7 讲中讨论过，

10
00:00:21,530 --> 00:00:22,230
枚举在第 7 讲中讨论过，

11
00:00:22,810 --> 00:00:24,900
结构体在第 8 讲中讨论过。

12
00:00:25,570 --> 00:00:27,870
复习这些章节为本讲做好准备。

13
00:00:30,160 --> 00:00:32,228
在本讲中，我们讲探讨何时

14
00:00:32,229 --> 00:00:33,420
方法很有用。

15
00:00:34,090 --> 00:00:35,739
我们将介绍如何定义方法

16
00:00:35,740 --> 00:00:37,560
然后演示如何调用方法。

17
00:00:38,380 --> 00:00:40,419
我们会简要提及关联函数

18
00:00:40,420 --> 00:00:42,429
以及它们与普通函数

19
00:00:42,430 --> 00:00:43,950
和方法的区别。

20
00:00:44,530 --> 00:00:46,479
最后我们将讨论

21
00:00:46,480 --> 00:00:48,489
仅需读取数据的方法

22
00:00:48,490 --> 00:00:50,220
仅需读取数据的方法

23
00:00:50,380 --> 00:00:52,359
与需要修改数据的方法之间的差异。

24
00:00:52,360 --> 00:00:53,340
与需要修改数据的方法之间的差异。

25
00:00:56,040 --> 00:00:58,070
让我们从方法的适用场景开始。

26
00:00:59,040 --> 00:01:00,869
来看一下第 8 讲中

27
00:01:00,870 --> 00:01:02,480
我们定义的 HockeyPlayer 结构体。

28
00:01:03,300 --> 00:01:04,760
仅凭这个定义，

29
00:01:04,950 --> 00:01:06,809
我们可以创建实例，

30
00:01:06,810 --> 00:01:08,759
读取其字段，

31
00:01:08,760 --> 00:01:10,660
如果实例是可变的还可以修改其字段值，

32
00:01:10,920 --> 00:01:11,890
但基本上也就这些功能了。

33
00:01:13,970 --> 00:01:15,889
我们想要模拟球员

34
00:01:15,890 --> 00:01:17,470
朝球门击球时的情况。

35
00:01:17,960 --> 00:01:19,819
那么，让我们从定义一个名为

36
00:01:19,820 --> 00:01:20,770
shoot_puck 的函数开始，

37
00:01:21,050 --> 00:01:22,939
然后逐步将这个函数转化为

38
00:01:22,940 --> 00:01:24,869
一个方法。shoot_puck 的函数

39
00:01:24,870 --> 00:01:27,340
接收一个 HockeyPlayer 实例，

40
00:01:27,590 --> 00:01:29,860
也就是即将要击球的球员。

41
00:01:31,040 --> 00:01:32,899
最终，这个函数可能会接收大量

42
00:01:32,900 --> 00:01:34,840
关于当前比赛状态的数据。

43
00:01:35,540 --> 00:01:37,609
现在，我们将从考虑

44
00:01:37,610 --> 00:01:39,439
本节比赛剩余秒数

45
00:01:39,440 --> 00:01:40,600
开始建模。

46
00:01:42,070 --> 00:01:44,179
这个函数的具体实现

47
00:01:44,180 --> 00:01:45,730
在目前并不重要。

48
00:01:46,150 --> 00:01:48,630
你可以自由选择一个实现，

49
00:01:48,760 --> 00:01:50,229
像是查看球员统计数据

50
00:01:50,230 --> 00:01:51,399
和剩余秒数，

51
00:01:51,400 --> 00:01:53,229
并根据你希望的冰球模拟器

52
00:01:53,230 --> 00:01:55,149
如何运作来打印出

53
00:01:55,150 --> 00:01:56,410
冰球是否进球。

54
00:01:57,160 --> 00:01:59,079
我们决定在我们这个

55
00:01:59,080 --> 00:02:00,690
非常不切实际的模拟中，

56
00:02:01,120 --> 00:02:03,150
所有球员总是能进球，

57
00:02:03,230 --> 00:02:05,100
然而当最后 5 分钟时，

58
00:02:05,350 --> 00:02:07,189
只有中锋

59
00:02:07,190 --> 00:02:09,579
才能保持镇定完成射门，

60
00:02:09,580 --> 00:02:11,460
而其他位置的球员则会射偏。

61
00:02:13,530 --> 00:02:14,939
这段代码运行正常

62
00:02:14,940 --> 00:02:16,400
并打印出“Goal!"。

63
00:02:18,470 --> 00:02:20,359
然而，我们并没有

64
00:02:20,360 --> 00:02:22,099
用最佳方式

65
00:02:22,100 --> 00:02:24,229
来写这个程序。在

66
00:02:24,230 --> 00:02:25,990
我们这个冰球模拟程序中，

67
00:02:26,330 --> 00:02:28,339
shoot_puck 函数只有在

68
00:02:28,340 --> 00:02:30,229
HockerPlayer 实例上下文中才有意义

69
00:02:30,230 --> 00:02:31,120
。

70
00:02:31,760 --> 00:02:33,899
其他类型，比如教练、球迷

71
00:02:33,900 --> 00:02:35,869
或者是吉祥物，按规定

72
00:02:35,870 --> 00:02:36,820
不能击打冰球。

73
00:02:37,580 --> 00:02:39,709
我们正在定义冰球运动员的行为，

74
00:02:39,710 --> 00:02:41,410
这是每个冰球运动员都应具备的，

75
00:02:41,810 --> 00:02:43,429
而且如果行为能明确与

76
00:02:43,430 --> 00:02:45,259
结构体关联，代码会更加有条理

77
00:02:45,260 --> 00:02:45,910
。

78
00:02:46,570 --> 00:02:47,950
这就是方法的用武之地。

79
00:02:50,130 --> 00:02:51,360
我们如何定义方法呢？

80
00:02:51,790 --> 00:02:52,720
让我们来了解一下。

81
00:02:54,010 --> 00:02:56,179
方法定义在

82
00:02:56,180 --> 00:02:58,120
以 impl 关键字开头的代码块里，

83
00:02:58,310 --> 00:03:00,110
impl 是 implementation 的缩写。

84
00:03:01,280 --> 00:03:03,109
然后我们指定为谁实现

85
00:03:03,110 --> 00:03:05,239
方法，在这个例子中，

86
00:03:05,240 --> 00:03:06,790
就是 HockeyPlayer 结构体。

87
00:03:07,700 --> 00:03:09,559
注意如果我们是为枚举类型实现方法

88
00:03:09,560 --> 00:03:11,749
这段代码看起来会和此处为结构体实现方法

89
00:03:11,750 --> 00:03:12,910
类似。

90
00:03:13,780 --> 00:03:15,639
我们只需要把枚举类型名放在

91
00:03:15,640 --> 00:03:17,460
现在结构体名称的位置即可。

92
00:03:18,100 --> 00:03:20,169
接下来用大括号开始

93
00:03:20,170 --> 00:03:22,149
代码块的主体。在

94
00:03:22,150 --> 00:03:24,179
代码块内，我们使用 fn 关键字

95
00:03:24,180 --> 00:03:25,310
和方法名，

96
00:03:25,560 --> 00:03:26,920
就像函数一样。

97
00:03:27,840 --> 00:03:29,369
函数和方法的一个重大区别

98
00:03:29,370 --> 00:03:31,429
是第一个参数，

99
00:03:31,430 --> 00:03:33,389
方法的第一个参数始终是

100
00:03:33,390 --> 00:03:35,249
某种形式的 sefl,指向

101
00:03:35,250 --> 00:03:37,320
方法实现的这个类型，

102
00:03:37,830 --> 00:03:39,920
在这个例子中就是 HockeryPlayer 实例。

103
00:03:40,290 --> 00:03:42,440
方法的其余参数

104
00:03:42,510 --> 00:03:44,699
和我们之前定义的函数相同

105
00:03:44,700 --> 00:03:45,410
。

106
00:03:45,900 --> 00:03:47,759
里面的无论如何具体实现都

107
00:03:47,760 --> 00:03:49,799
保持不变，除了

108
00:03:49,800 --> 00:03:51,680
使用 HockeyPlayer 参数的地方，

109
00:03:51,780 --> 00:03:52,619
你现在要用 self

110
00:03:52,620 --> 00:03:53,330
来替代。

111
00:03:55,180 --> 00:03:57,099
现在我们定义了一个方法，那么

112
00:03:57,100 --> 00:03:58,370
调用它又是什么样子呢？

113
00:04:00,340 --> 00:04:02,139
与使用函数名

114
00:04:02,140 --> 00:04:03,969
并传递冰球运动员实例

115
00:04:03,970 --> 00:04:05,400
作为第一个参数不同，

116
00:04:06,010 --> 00:04:08,180
我们可以指定冰球运动员实例，

117
00:04:08,280 --> 00:04:09,939
然后加一个点，再输入

118
00:04:09,940 --> 00:04:11,430
我们想要调用的方法名，

119
00:04:11,680 --> 00:04:14,040
以及除 self 外的其余参数。

120
00:04:15,980 --> 00:04:17,869
现在这段代码的运行效果

121
00:04:17,870 --> 00:04:19,900
与 shoot_puck 作为函数时完全一样，

122
00:04:20,500 --> 00:04:22,369
但我们更清晰地表达了

123
00:04:22,370 --> 00:04:24,259
击球是冰球运动员实例

124
00:04:24,260 --> 00:04:25,570
所具备的行为。

125
00:04:27,600 --> 00:04:29,639
与方法相关的是

126
00:04:29,640 --> 00:04:31,599
关联函数。让我们

127
00:04:31,600 --> 00:04:33,720
来简单看一下关联函数，

128
00:04:34,000 --> 00:04:35,079
看看它们与

129
00:04:35,080 --> 00:04:36,219
常规函数以及

130
00:04:36,220 --> 00:04:37,320
方法的区别。

131
00:04:39,390 --> 00:04:41,399
关联函数定义在

132
00:04:41,400 --> 00:04:43,679
结构体或枚举的实现块中，

133
00:04:43,680 --> 00:04:46,120
这与方法相同。

134
00:04:47,260 --> 00:04:49,590
它们仍然是与该类型相关的行为，

135
00:04:50,080 --> 00:04:51,939
因此我们希望将这些行为组织起来，

136
00:04:51,940 --> 00:04:53,049
使其与类型

137
00:04:53,050 --> 00:04:54,909
相关联。与

138
00:04:54,910 --> 00:04:56,739
方法不同，它们不将 self

139
00:04:56,740 --> 00:04:59,079
作为参数。关联函数

140
00:04:59,080 --> 00:05:01,119
通常用于创建

141
00:05:01,120 --> 00:05:03,099
类型实例，

142
00:05:03,100 --> 00:05:05,139
因此它们没有可操作的 self 实例

143
00:05:05,140 --> 00:05:05,640
。

144
00:05:07,730 --> 00:05:09,769
例如，这里有一个

145
00:05:09,770 --> 00:05:11,440
名为 new 的关联函数，

146
00:05:11,740 --> 00:05:13,579
它根据给定的

147
00:05:13,580 --> 00:05:15,469
姓名、

148
00:05:15,470 --> 00:05:16,930
号码和位置创建 HockeyPlayer 结构体实例。

149
00:05:18,140 --> 00:05:20,029
该函数总是将 goals_ytd 字段

150
00:05:20,030 --> 00:05:22,120
初始化为 0.

151
00:05:23,050 --> 00:05:24,999
请注意，new 在 Rust 中并非

152
00:05:25,000 --> 00:05:26,899
像 Ruby 等语言那样

153
00:05:26,900 --> 00:05:28,280
是特殊函数名，

154
00:05:28,830 --> 00:05:30,699
但按照惯例，许多 Rust 类型

155
00:05:30,700 --> 00:05:32,649
会定义一个名为

156
00:05:32,650 --> 00:05:33,270
new 的关联函数

157
00:05:33,510 --> 00:05:35,730
用于创建该类型的新实例。

158
00:05:37,590 --> 00:05:39,510
要调用关联函数，

159
00:05:39,780 --> 00:05:41,799
请指定类型名称，然后

160
00:05:41,800 --> 00:05:43,910
两个冒号，再跟函数名。

161
00:05:44,670 --> 00:05:46,619
关联函数被置于类型名之下，

162
00:05:46,620 --> 00:05:47,930
形成自己的命名空间。

163
00:05:48,450 --> 00:05:50,459
这段代码的功能与之前

164
00:05:50,460 --> 00:05:52,379
我们拥有的代码类似，

165
00:05:52,380 --> 00:05:54,140
都是创建一个新的冰球运动员实例。

166
00:05:54,780 --> 00:05:56,699
区别在于年度进球数字段

167
00:05:56,700 --> 00:05:58,520
将会是 0 而不是 7.

168
00:06:00,620 --> 00:06:02,020
回到讨论方法上，

169
00:06:02,480 --> 00:06:04,519
我们来聊聊方法中

170
00:06:04,520 --> 00:06:06,349
self 的不同形式，

171
00:06:06,350 --> 00:06:08,269
这关系到方法是否只需要

172
00:06:08,270 --> 00:06:09,160
读取数据

173
00:06:09,500 --> 00:06:11,410
还是也需要写入数据。

174
00:06:13,630 --> 00:06:15,609
我们实际上忽略了当前代码存在的

175
00:06:15,610 --> 00:06:17,679
一个问题：一个球员实例

176
00:06:17,680 --> 00:06:19,950
只能击球一次。

177
00:06:20,730 --> 00:06:22,739
如果我们尝试再次让同一个球员再次击球

178
00:06:22,740 --> 00:06:23,360
，

179
00:06:23,760 --> 00:06:25,619
就会收到错误提示：

180
00:06:25,620 --> 00:06:27,110
使用了已移动的值：'player'。

181
00:06:27,300 --> 00:06:29,129
这与 Rust 的所有权系统

182
00:06:29,130 --> 00:06:30,140
有关，

183
00:06:30,510 --> 00:06:32,790
下一章节将全面讲解所有权概念，

184
00:06:33,150 --> 00:06:35,129
所以不必急于此时理解

185
00:06:35,130 --> 00:06:36,530
为何会出现这个错误。

186
00:06:38,660 --> 00:06:40,529
在这个场景下定义

187
00:06:40,530 --> 00:06:42,160
shoot_puck 方法

188
00:06:42,350 --> 00:06:44,179
更好的方式是使用借用

189
00:06:44,180 --> 00:06:46,069
而不是获取所有权，

190
00:06:46,070 --> 00:06:47,189
我们使用 & 符号来表示借用。

191
00:06:47,190 --> 00:06:49,149
再次强调，

192
00:06:49,150 --> 00:06:51,139
我们将在下一章节深入探讨

193
00:06:51,140 --> 00:06:52,150
这个主题。

194
00:06:52,790 --> 00:06:54,889
进行这个修改后错误就修复了，

195
00:06:54,890 --> 00:06:56,719
现在我们可以多次调用击球方法了

196
00:06:56,720 --> 00:06:57,520
。

197
00:06:59,520 --> 00:07:01,379
&self 用于那些

198
00:07:01,380 --> 00:07:03,369
不会改变 self 值的方法

199
00:07:03,370 --> 00:07:05,219
。

200
00:07:05,220 --> 00:07:07,319
在这个实现中，我们只是读取

201
00:07:07,320 --> 00:07:09,179
HockerPlayer 实例的 position 字段

202
00:07:09,180 --> 00:07:11,330
而不做任何修改。

203
00:07:13,190 --> 00:07:15,490
假设我们确实想要修改 seflt,

204
00:07:15,710 --> 00:07:17,599
在击球

205
00:07:17,600 --> 00:07:19,699
且得分时

206
00:07:19,700 --> 00:07:21,110
增加 goals_ytd 的计数。

207
00:07:23,920 --> 00:07:24,909
当我们做了这个修改

208
00:07:24,910 --> 00:07:26,460
并尝试编译代码时，

209
00:07:26,860 --> 00:07:28,749
会得到一个错误提示，说我们不能对

210
00:07:28,750 --> 00:07:30,300
goals_ytd 字段赋值。

211
00:07:32,320 --> 00:07:34,389
就像我们必须显式标注

212
00:07:34,390 --> 00:07:36,090
可变变量一样，

213
00:07:36,610 --> 00:07:38,549
我们也必须在可修改 self 的方法上标注

214
00:07:38,550 --> 00:07:38,950
。

215
00:07:40,030 --> 00:07:41,949
我们通过将方法的第一个参数设定为

216
00:07:41,950 --> 00:07:44,120
&mut self 来实现这一点。

217
00:07:46,100 --> 00:07:47,359
这样就修复了错误，

218
00:07:47,360 --> 00:07:49,369
我们可以看到方法已经

219
00:07:49,370 --> 00:07:50,470
修改了 player 实例。

220
00:07:52,190 --> 00:07:53,290
在本讲中，

221
00:07:53,360 --> 00:07:54,589
我们介绍了如何用方法

222
00:07:54,590 --> 00:07:56,870
为数据类型添加行为，

223
00:07:57,230 --> 00:07:59,290
如何定义和调用方法，

224
00:07:59,730 --> 00:08:01,669
以及在 impl 实现块中，

225
00:08:01,670 --> 00:08:02,869
定义和类型相关联的

226
00:08:02,870 --> 00:08:03,710
关联函数，

227
00:08:03,740 --> 00:08:05,630
而这个函数和类型实例无关，

228
00:08:06,350 --> 00:08:08,269
以及方法根据

229
00:08:08,270 --> 00:08:10,399
读取或写入数据的需求

230
00:08:10,400 --> 00:08:11,470
所采用的各种 self 形式。

231
00:08:12,770 --> 00:08:14,410
这些就是方法的基础知识，

232
00:08:14,770 --> 00:08:16,659
也是本章语法介绍的结尾

233
00:08:16,660 --> 00:08:17,380
。

234
00:08:18,520 --> 00:08:19,380
下一章，

235
00:08:19,600 --> 00:08:21,789
我们将全面了解所有权和

236
00:08:21,790 --> 00:08:22,660
借用的概念。

237
00:08:23,320 --> 00:08:25,870
我们会熟悉何时应该添加 & 符号。

