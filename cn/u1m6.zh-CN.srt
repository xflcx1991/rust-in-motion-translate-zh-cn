1
00:00:02,270 --> 00:00:09,619
 控制流功能让你的代码在某种情况采取一种操作，在另一种情况时采取另一种操作。它们是你在代码中表达决策的方式。

2
00:00:09,619 --> 00:00:28,020
在本节中，我们将介绍if、else if 和 else；三种不同的循环：loop、while 和 for；以及匹配表达式。我们将在本节中定义和调用函数，

3
00:00:28,240 --> 00:00:30,260
所以如果你需要复习的话，

4
00:00:30,270 --> 00:00:31,170
请查看前面的函数一节。

5
00:00:32,740 --> 00:00:48,950
让我们从 if、else if 和 else 开始。我们可以编写只使用 if 的代码，方法是以 if 关键字开头，然后是一个结果为 boolean 的表达式，然后是大括号，里面包含如果 boolean 表达式如果为真是要执行的代码。

6
00:00:49,840 --> 00:00:51,640
如果条件为假，

7
00:00:51,720 --> 00:00:55,820
大括号里的代码就不会执行。

8
00:00:55,880 --> 00:01:00,210
可选的 ，你还可以使用 else 块以和 if 块一起使用，

9
00:01:00,220 --> 00:01:02,050
else 块的代码会在条件表达式为假的时候执行。

10
00:01:04,140 --> 00:01:08,470
你也可以使用多个条件判断，通过一个 if 代码块和

11
00:01:08,470 --> 00:01:10,050
 一个 else if 代码块，

12
00:01:10,540 --> 00:01:12,250
再然后是任意多的 else if 代码块，

13
00:01:13,240 --> 00:01:15,300
再然后是可选的 else 代码块，

14
00:01:15,310 --> 00:01:20,540
如果上面所有的条件判断都为假，这个 else 代码块就会执行。

15
00:01:20,630 --> 00:01:26,550
和函数一样，我们可以从 if 或 else 代码块中得到一个值，方法是在该块里的最后一个表达式不加分号。

16
00:01:27,540 --> 00:01:29,450
然后我们就可以把这个值放到一个变量中。

17
00:01:30,240 --> 00:01:30,500
注意，

18
00:01:30,500 --> 00:01:33,350
我们确实需要一个分号来结束变量赋值语句。

19
00:01:34,940 --> 00:01:35,920
这段代码会打印

20
00:01:36,069 --> 00:01:37,650
Your discount is 50!.

21
00:01:39,980 --> 00:01:44,150
请注意，当我们从一个变量的 if else 表达式中返回一个值时，

22
00:01:44,740 --> 00:01:51,350
必须有一个 else 子句，以便该变量总是能得到一个值。而且这些值的类型必须相同，

23
00:01:51,740 --> 00:01:52,450
在本例中是 i32。

24
00:01:52,530 --> 00:01:53,250


25
00:01:55,540 --> 00:01:56,120
接下来，

26
00:01:56,250 --> 00:01:57,250
我们谈谈 loop 循环。

27
00:01:59,040 --> 00:02:01,220
loop 循环让你重复运行相同的代码。

28
00:02:02,670 --> 00:02:06,750
loop 关键字可以指定一段永远运行的代码块。

29
00:02:07,640 --> 00:02:09,210
这个例子里的循环会反复打印 hello,world!

30
00:02:09,220 --> 00:02:10,250


31
00:02:12,139 --> 00:02:14,350
这段代码永不会停止运行。

32
00:02:14,940 --> 00:02:16,139
我们得使用 Ctrl+C 来停止它。

33
00:02:16,139 --> 00:02:16,450


34
00:02:18,240 --> 00:02:20,550
你可以使用 break 关键字来退出 loop 循环。

35
00:02:21,940 --> 00:02:23,560
这个例子会一直循环，

36
00:02:23,850 --> 00:02:25,850
会打印 What's the secret word?

37
00:02:26,340 --> 00:02:29,970
并等待输入，除非你输入了正确的密码：rust。在这种情况下，程序会跳出循环。

38
00:02:30,010 --> 00:02:40,550
当我们运行这个程序，并输入 java，循环会再次询问，

39
00:02:41,080 --> 00:02:42,280
当我们输入 rust 时，

40
00:02:42,530 --> 00:02:44,950
代码就会跳出循环，程序就会结束。

41
00:02:47,639 --> 00:02:48,720
这里的代码我们用的是

42
00:02:48,720 --> 00:02:53,150
loop、if 和 break，也可以使用 while 循环。

43
00:02:54,139 --> 00:03:01,870
while 循环语法是用 while 关键字，然后一个结果为 true 或 flase 的表达式，然后是大括号和一个代码块。

44
00:03:03,139 --> 00:03:04,980
当指定的表达式为真时，

45
00:03:04,980 --> 00:03:06,990
该块中的代码就会反复运行。

46
00:03:09,040 --> 00:03:12,350
这里是一个使用 while 循环的密语例子。

47
00:03:13,139 --> 00:03:16,250
它和刚才 loop 例子的结果完全一致，但更简洁一些。

48
00:03:17,740 --> 00:03:21,250
循环何时退出的条件现在是循环开始的一部分，

49
00:03:21,740 --> 00:03:23,310
而不是循环里的某个地方。

50
00:03:25,990 --> 00:03:28,950
for 循环可能是 Rust 代码中最常见的循环。

51
00:03:29,880 --> 00:03:32,650
它可以让你为集合中的每个条目运行一些代码。

52
00:03:33,870 --> 00:03:36,150
不像其他语言中的 for 循环，比如 C 语言，

53
00:03:36,840 --> 00:03:39,980
你不需要管理集合的索引，也不需要

54
00:03:39,980 --> 00:03:44,950
担心差一错误（off-by-one errors)。

55
00:03:45,340 --> 00:03:46,450
要写 for 循环，使用 for 关键字，

56
00:03:47,240 --> 00:03:56,750
然后选一个变量名，以指代每次循环中集合中的某一项。然后，写上 in 关键字和你要遍历的集合。

57
00:03:57,640 --> 00:04:00,810
然后，加上大括号和为每个条目要执行的代码。

58
00:04:03,540 --> 00:04:09,790
这个例子中，对于这个集合，我们使用范围语法：两个点，来创建一个整数范围，

59
00:04:09,800 --> 00:04:15,450
从 1 到 11（不包括）。

60
00:04:15,940 --> 00:04:21,450
对于这个范围内的每个数字，for 循环将会打印 Now serving number 和当前循环的这个数字。

61
00:04:22,440 --> 00:04:28,950
我们可以看到这段代码以打印 Now serving number 1 开始，以 Now serving number 10 结束。

62
00:04:31,240 --> 00:04:31,810
最后，

63
00:04:32,050 --> 00:04:33,750
让我们来谈谈匹配表达式，

64
00:04:35,140 --> 00:04:38,050
匹配语句（译者注：不翻译直接用 match更好）不是一个很多编程语言都有的东西。

65
00:04:38,839 --> 00:04:39,970
它有点像一堆

66
00:04:39,980 --> 00:04:42,920
if/else if 语句，也稍微有点像

67
00:04:42,930 --> 00:04:43,170
switch-case 语句，

68
00:04:43,170 --> 00:04:43,750


69
00:04:44,339 --> 00:04:46,050
但有两个比它们更好的原因：

70
00:04:46,540 --> 00:04:48,550
模式匹配和穷举检查。

71
00:04:50,140 --> 00:04:50,700
首先，

72
00:04:50,870 --> 00:04:52,250
让我们来谈谈模式匹配。

73
00:04:53,740 --> 00:04:57,050
模式匹配是 Rust 中多个地方都有的功能。

74
00:04:57,940 --> 00:05:01,850
实际上在数据类型一节，我们已经使用了模式匹配来将元组分解成

75
00:05:02,279 --> 00:05:03,550
若干部分。真是一个惊喜！

76
00:05:04,040 --> 00:05:09,750
模式匹配在匹配表达式中特别有用。

77
00:05:10,440 --> 00:05:19,050
我们指定一个模式列表来测试一个值，匹配表达式根据每个模式检测这个值，如果找到一个匹配的模式就停止。

78
00:05:20,040 --> 00:05:21,980
然后就运行和该模式匹配的代码。

79
00:05:24,740 --> 00:05:26,779
下面是一个匹配表达式的例子。

80
00:05:27,640 --> 00:05:29,850
我们在变量 x 中存储了一个整数，

81
00:05:30,339 --> 00:05:32,850
然后用 x 和一些模式进行匹配。

82
00:05:33,640 --> 00:05:34,330
在这个例子中，

83
00:05:34,339 --> 00:05:36,070
这些模式都是数字字面量。

84
00:05:37,940 --> 00:05:40,210
Rust 做的是将 x，

85
00:05:40,400 --> 00:05:44,650
本例子中是 3，与 1 进行比较，并不匹配。

86
00:05:45,140 --> 00:05:46,810
因此接着继续和下一个模式，2，去比较，

87
00:05:46,870 --> 00:05:47,350


88
00:05:47,740 --> 00:05:51,020
也不匹配，接下来是 3，

89
00:05:51,029 --> 00:05:51,529


90
00:05:51,810 --> 00:05:52,900
这次匹配上了。

91
00:05:53,140 --> 00:05:56,950
因此这里会打印 Thres's a crowed，并结束这段匹配表达式。

92
00:05:58,279 --> 00:06:06,339
模式列表中的最后一个项，下划线，代表匹配任何值。所以最后一项的功能就像 if/else if/else 代码块中的

93
00:06:06,350 --> 00:06:07,050
else 的一样。

94
00:06:07,050 --> 00:06:08,250


95
00:06:10,040 --> 00:06:13,150
有很多不同的想法可以用模式匹配来表达。

96
00:06:14,240 --> 00:06:19,050
比如这个例子展示了一些逻辑，可能会用在两个骰子弹棋盘游戏中。

97
00:06:19,640 --> 00:06:22,850
为了简化这个例子，我们对骰子的值进行了硬编码。

98
00:06:23,339 --> 00:06:29,130
match 里面第一行匹配的是两个骰子都是1的情况。第二行匹配

99
00:06:29,140 --> 00:06:30,089
两个骰子中

100
00:06:30,089 --> 00:06:31,339
某一个是 5 的情况，

101
00:06:31,790 --> 00:06:37,450
但具体是哪个并不重要，我们在元祖模式中使用下划线来忽略这个位置上的值。

102
00:06:38,880 --> 00:06:50,240
两个模式之间的竖线表示逻辑或。还要注意的是，我们可以在某个模式里加上大括号，让多行代码与模式配对。（译者注：说得这么啰嗦，就是匹配该模式后可以用大括号来执行多行代码）

103
00:06:50,250 --> 00:06:55,850
同样的，最后一个模式这里又是一个下划线，它将匹配元祖的任何值，任何上面都没匹配成功的情况。

104
00:06:57,779 --> 00:06:58,650
这段代码会打印出，

105
00:06:59,040 --> 00:07:01,080
You rolled at least one 5!Move and

106
00:07:01,080 --> 00:07:01,880
then roll again!.

107
00:07:04,540 --> 00:07:10,050
匹配表达式另一个很棒的点是，它们必须穷尽地覆盖了每一种情况。

108
00:07:10,740 --> 00:07:14,350
这可以防止因忘记处理某种情况而引起的错误。

109
00:07:15,640 --> 00:07:16,350
例如，

110
00:07:16,840 --> 00:07:19,480
这里有一个 match 语句，我们要检查两个布尔值：

111
00:07:19,760 --> 00:07:21,540
is_confirmed 和 is_active。

112
00:07:22,440 --> 00:07:23,490
这里我们忘记了

113
00:07:23,490 --> 00:07:26,450
is_confirmed 为 true，is_active 为 false 的情况。

114
00:07:28,640 --> 00:07:30,790
如果我们尝试编译这段代码，

115
00:07:30,790 --> 00:07:34,900
Rust 会提示我们没有覆盖所有可能性。在这个例子中，

116
00:07:34,960 --> 00:07:37,150
编译器甚至能够告诉我们缺少了哪种情况。

117
00:07:37,640 --> 00:07:37,950
谢谢你，

118
00:07:37,950 --> 00:07:38,350
Rust!

119
00:07:40,640 --> 00:07:52,780
我们可以通过明确添加缺少的情况，或者通过使用下划线来显式指出我们就是要忽略其他情况来解决这个问题。

120
00:07:52,920 --> 00:07:54,620
在本节中，我们介绍了了 if、else if、

121
00:07:54,620 --> 00:07:57,990
else 结构，这种结构会有条件地运行代码块；

122
00:07:59,070 --> 00:08:01,470
loop 关键字，它会永远重复运行代码块；

123
00:08:01,470 --> 00:08:04,770
while 循环，它在条件为真的时候

124
00:08:04,770 --> 00:08:05,950
重复运行代码；

125
00:08:06,980 --> 00:08:17,650
for 循环，它在一个集合中迭代每个元素；以及匹配表达式，它使用模式匹配和穷举检查来处理一个值的所有可能情况。

126
00:08:18,940 --> 00:08:20,850
以上这些是构建复杂逻辑所需要的。

127
00:08:22,540 --> 00:08:23,440
下一节，

128
00:08:23,520 --> 00:08:29,050
让我们来探索枚举——一种定义自定义类型的方法，可以很好地与匹配表达式一起工作。

