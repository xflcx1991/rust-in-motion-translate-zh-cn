1
00:00:02,160 --> 00:00:03,930
欢迎回来，Rust 开发者们！

2
00:00:04,170 --> 00:00:06,030
在上一讲“变量”中，

3
00:00:06,030 --> 00:00:07,230
提到每个 Rust 的变量

4
00:00:07,230 --> 00:00:09,270
都有类型。或许你已经

5
00:00:09,270 --> 00:00:11,100
在其他语言中接触过和 Rust 类似的类型了，

6
00:00:11,100 --> 00:00:12,869
这些语言有 C，Ruby，

7
00:00:12,869 --> 00:00:13,640
Java。

8
00:00:14,250 --> 00:00:16,110
在这一讲，我们将会讲到

9
00:00:16,110 --> 00:00:18,390
由语言核心提供的基本类型，

10
00:00:18,390 --> 00:00:20,010
这会让你更加熟悉在 Rust 中如何使用他们。

11
00:00:20,010 --> 00:00:22,190
 在之后的章节里，

12
00:00:22,290 --> 00:00:24,239
我们还会讲到可以由你设计的自定义类型。

13
00:00:24,239 --> 00:00:24,880


14
00:00:26,440 --> 00:00:27,950
让我们从 Booleans 开始吧。

15
00:00:28,780 --> 00:00:30,070
Booleans 在 Rust 中的类型名是“bool”。

16
00:00:30,070 --> 00:00:31,840
 1个 Boolean 型变量

17
00:00:31,840 --> 00:00:33,040
的值可以是 true

18
00:00:33,040 --> 00:00:35,380
或者 false。Booleans 常常用在

19
00:00:35,380 --> 00:00:37,330
条件判断中，

20
00:00:37,330 --> 00:00:38,880
例如 if 语句和 while 语句。

21
00:00:40,210 --> 00:00:42,720
看这儿的两个 Boolean 型变量，

22
00:00:43,060 --> 00:00:45,000
变量 a 被赋值 true，

23
00:00:45,190 --> 00:00:47,060
变量 b 被赋值 false。

24
00:00:48,240 --> 00:00:49,500
头一个 if 语句

25
00:00:49,500 --> 00:00:50,710
判断 a，

26
00:00:50,729 --> 00:00:51,840
第二个 if 语句判断 b。

27
00:00:51,840 --> 00:00:54,030
 由于只有 a 是 true，

28
00:00:54,030 --> 00:00:56,400
这个代码将只会执行

29
00:00:56,400 --> 00:00:58,340
第一个花括号的代码块，并输出"a is true!"。

30
00:00:58,340 --> 00:00:58,850


31
00:01:00,830 --> 00:01:02,880
接下来，我们转向学习整型。

32
00:01:03,920 --> 00:01:05,870
在 Rust 里，没有小数点的数字

33
00:01:05,870 --> 00:01:07,209
就是整型数字。

34
00:01:07,670 --> 00:01:10,090
整型还分两种：有符号

35
00:01:10,090 --> 00:01:10,990
和无符号。

36
00:01:11,790 --> 00:01:13,770
进一步地，你还需要确定

37
00:01:13,770 --> 00:01:15,890
你要用的整数要占用多少空间，

38
00:01:16,140 --> 00:01:18,470
这会影响整数变量能存储多大的整数。

39
00:01:19,370 --> 00:01:21,360
这种精打细算的思考会让你的程序恰好

40
00:01:21,360 --> 00:01:22,770
只使用够用的内存，

41
00:01:22,770 --> 00:01:23,660
不会浪费空间。

42
00:01:24,980 --> 00:01:27,060
每种类型中的数字代表

43
00:01:27,080 --> 00:01:29,000
在程序中它要占多少比特的空间。

44
00:01:29,000 --> 00:01:31,450


45
00:01:32,480 --> 00:01:33,490
例如，

46
00:01:33,500 --> 00:01:35,920
一个 i8 型变量占用8比特空间。

47
00:01:35,959 --> 00:01:37,870
由于 i 代表有符号的意思，

48
00:01:38,180 --> 00:01:40,010
最高位的比特位用来表示

49
00:01:40,010 --> 00:01:41,660
这个数字是正数还是负数。

50
00:01:41,660 --> 00:01:42,430


51
00:01:43,010 --> 00:01:44,870
其余比特位才是存储该变量的值。

52
00:01:44,870 --> 00:01:45,569


53
00:01:46,500 --> 00:01:48,480
这意味着一个 i8 型变量能

54
00:01:48,480 --> 00:01:51,140
存储的值的范围是-128

55
00:01:51,180 --> 00:01:53,270
到127。

56
00:01:55,210 --> 00:01:57,160
如果你要存的数字

57
00:01:57,160 --> 00:01:58,680
只可能是0或这正数，

58
00:01:59,050 --> 00:02:00,580
你可以使用一个无符号类型变量

59
00:02:00,580 --> 00:02:01,260
来代替。

60
00:02:01,660 --> 00:02:03,520
无符号类型使用字母 u

61
00:02:03,520 --> 00:02:05,150
代替 i。

62
00:02:06,040 --> 00:02:07,960
由于无符号类型不使用

63
00:02:07,960 --> 00:02:09,740
额外的1比特位来存储符号，

64
00:02:10,000 --> 00:02:12,320
该类型变量能存储的值的范围有所不同。

65
00:02:12,330 --> 00:02:14,470
一个 u8 型变量存储的值的范围

66
00:02:14,470 --> 00:02:15,400
是0到

67
00:02:15,400 --> 00:02:17,639
255。

68
00:02:18,910 --> 00:02:21,350
isize 和 usize 类型能存储的值的范围和

69
00:02:21,350 --> 00:02:22,800
硬件相关。

70
00:02:23,020 --> 00:02:24,940
如果跑在 32位机器上，

71
00:02:24,940 --> 00:02:27,120
isize 和 usize要占用 32比特的空间。

72
00:02:27,490 --> 00:02:29,520
但如果运行在 64位机器上，那

73
00:02:29,620 --> 00:02:31,200
它们就会占用 64比特空间。

74
00:02:31,630 --> 00:02:33,580
与此类似，指针占用空间的大小也和上述类型一样，

75
00:02:33,580 --> 00:02:34,730
和机器类型相关。

76
00:02:35,550 --> 00:02:36,690
可以使用 isize

77
00:02:36,690 --> 00:02:39,030
或 usize 来索引集合

78
00:02:39,030 --> 00:02:40,280
或用来计数。

79
00:02:41,510 --> 00:02:42,400
如图所示代码，

80
00:02:42,900 --> 00:02:44,919
a 是包含整形数字的数组，

81
00:02:45,110 --> 00:02:47,450
用来索引的数字0

82
00:02:47,450 --> 00:02:48,990
是 usize 类型。

83
00:02:49,910 --> 00:02:51,790
我们稍后再讲一下数组。

84
00:02:52,780 --> 00:02:54,630
默认情况下，

85
00:02:54,820 --> 00:02:56,740
在 Rust 中写了一个不带小数点的数字，

86
00:02:56,740 --> 00:02:58,700
那它的类型就是 i32.

87
00:02:58,700 --> 00:02:59,120


88
00:02:59,790 --> 00:03:01,870
如果你不确定要用哪种整数类型，

89
00:03:01,870 --> 00:03:03,360
那 i32 就是个不错的默认选项。

90
00:03:04,870 --> 00:03:07,380
接下来，聊聊浮点数。

91
00:03:08,340 --> 00:03:10,290
带有小数点的数字称为

92
00:03:10,290 --> 00:03:11,510
浮点数。

93
00:03:12,120 --> 00:03:14,630
就像整数一样，浮点数也有不同尺寸的类型：

94
00:03:14,960 --> 00:03:16,040
f32

95
00:03:16,050 --> 00:03:18,330
和 f64，

96
00:03:18,330 --> 00:03:20,230
分别使用 32bit 和 64bit 空间。

97
00:03:21,470 --> 00:03:23,360
浮点数的默认类型是

98
00:03:23,360 --> 00:03:25,310
f64，

99
00:03:25,310 --> 00:03:27,760
这比 f32 提供了更高的精度。

100
00:03:28,889 --> 00:03:30,389
在计算机中操作浮点数

101
00:03:30,389 --> 00:03:32,139
可能是个复杂问题。

102
00:03:32,669 --> 00:03:33,570
如果你从来没处理过

103
00:03:33,570 --> 00:03:34,580
浮点数问题，

104
00:03:34,830 --> 00:03:36,280
请阅读《The Floating-Point Guide》（https://floating-point-gui.de/ 译者按）

105
00:03:37,690 --> 00:03:39,510
字符类型是简单类型中的最后

106
00:03:39,510 --> 00:03:40,290
一种。

107
00:03:40,660 --> 00:03:42,550
Rust 可以将单个字符

108
00:03:42,550 --> 00:03:44,010
作为 char 类型存储。

109
00:03:44,530 --> 00:03:46,950
char 是一个 Unicoce scalar value（术语，参看 https://zhuanlan.zhihu.com/p/53714077 理解，译者按）

110
00:03:47,040 --> 00:03:49,380
所以它能保存的不仅仅是 ASCII 值。

111
00:03:49,690 --> 00:03:51,570
由于人类的语言是复杂的，

112
00:03:51,730 --> 00:03:53,560
Rust 里的 char 可能不符合

113
00:03:53,560 --> 00:03:55,610
我们人类所期望的字符的样子。

114
00:03:56,630 --> 00:03:57,590
字符被单引号

115
00:03:57,590 --> 00:03:58,840
包裹的。

116
00:03:59,210 --> 00:04:01,200
不要把它们和双引号包裹的字符串混淆。

117
00:04:01,200 --> 00:04:01,680
quotes.

118
00:04:03,380 --> 00:04:05,330
布尔类型，整数类型，浮点数类型，

119
00:04:05,330 --> 00:04:07,250
和字符类型是刚刚讲的

120
00:04:07,250 --> 00:04:09,040
内置的简单类型。

121
00:04:09,230 --> 00:04:11,440
接下来是内置的复合类型，

122
00:04:11,510 --> 00:04:12,760
先从元组开始。

123
00:04:13,770 --> 00:04:15,600
元组允许你将多个值  

124
00:04:15,600 --> 00:04:17,260
用括号组合在一起。

125
00:04:17,670 --> 00:04:19,500
这些多个值不必是

126
00:04:19,500 --> 00:04:20,230
相同类型。

127
00:04:21,240 --> 00:04:22,890
看这个例子，tup变量是

128
00:04:22,890 --> 00:04:24,420
一个有3个元素的tuple（后面类型术语就不翻译了，译者按）：

129
00:04:25,100 --> 00:04:26,380
一个 i32，

130
00:04:26,710 --> 00:04:27,390
一个 char，

131
00:04:27,700 --> 00:04:28,500
和一个 bool。

132
00:04:28,960 --> 00:04:31,420
为了从tuple里获取单个元素，

133
00:04:31,420 --> 00:04:33,029
可以使用tuple索引。

134
00:04:33,980 --> 00:04:36,110
tuple索引用点号跟着

135
00:04:36,110 --> 00:04:38,270
你想要获取的元素的索引来表达，索引

136
00:04:38,270 --> 00:04:39,010
从0开始。

137
00:04:39,690 --> 00:04:41,630
这段代码打印“the first is

138
00:04:41,630 --> 00:04:43,000
1”，和

139
00:04:43,220 --> 00:04:44,480
“the second is c”。

140
00:04:45,250 --> 00:04:47,820
要将tuple拆成多个值，

141
00:04:47,890 --> 00:04:49,410
可使用解构语法。

142
00:04:49,960 --> 00:04:51,930
要做到这一点，在等号左边

143
00:04:51,930 --> 00:04:53,860
使用符合tuple结构的

144
00:04:53,860 --> 00:04:55,880
let语句。

145
00:04:55,880 --> 00:04:56,430


146
00:04:56,680 --> 00:04:58,500
这个语句让x等于1，

147
00:04:59,080 --> 00:05:00,960
y等于'c'，

148
00:05:01,240 --> 00:05:03,000
z等于布尔值 true。

149
00:05:04,250 --> 00:05:05,410
接下来我们聊聊

150
00:05:05,410 --> 00:05:06,150
数组。

151
00:05:07,410 --> 00:05:09,440
rust中的数组是一个集合，

152
00:05:09,440 --> 00:05:11,400
其中所有元素都有相同的类型。

153
00:05:12,310 --> 00:05:14,140
这里有个包含3个 f64 类型元素

154
00:05:14,140 --> 00:05:15,450
的数组。

155
00:05:16,230 --> 00:05:18,560
你可以通过使用方括号

156
00:05:18,660 --> 00:05:20,070
和索引值

157
00:05:20,070 --> 00:05:21,740
来访问数组中的每个元素，

158
00:05:22,020 --> 00:05:23,060
索引值从0开始。

159
00:05:23,640 --> 00:05:25,560
这段代码将会输出数组的第2个元素，

160
00:05:25,560 --> 00:05:27,470
3.14。

161
00:05:28,440 --> 00:05:30,330
还可以用方括号语法

162
00:05:30,330 --> 00:05:31,670
来修改某个位置的元素。

163
00:05:32,190 --> 00:05:33,720
这段代码将把数组的

164
00:05:33,720 --> 00:05:35,900
第一个元素设置为0，并打引出来。

165
00:05:36,760 --> 00:05:38,710
运行这段代码，

166
00:05:38,710 --> 00:05:40,610
可以看到值确实改变了。

167
00:05:42,200 --> 00:05:44,160
数组在初始化完成后

168
00:05:44,160 --> 00:05:46,290
长度是固定的。不能再变得

169
00:05:46,290 --> 00:05:48,300
更大或更小。尽管

170
00:05:48,300 --> 00:05:50,240
数组b是可变的，

171
00:05:50,250 --> 00:05:52,200
但我们不能向其再增加元素，

172
00:05:52,200 --> 00:05:54,290
使它变成4个元素而不是3个。

173
00:05:54,960 --> 00:05:57,270
如果尝试向数组添加元素，

174
00:05:57,270 --> 00:05:58,960
编译器不会允许这样做。

175
00:05:59,430 --> 00:06:01,390
如果需要一个可变的集合，

176
00:06:01,390 --> 00:06:03,620
可以使用Vec，

177
00:06:03,670 --> 00:06:05,760
Vec是标准库提供的类型。

178
00:06:06,620 --> 00:06:08,740
另一种很常见的原始类型是

179
00:06:08,750 --> 00:06:10,060
slice。

180
00:06:10,339 --> 00:06:12,500
slice可以引用另一个数据中

181
00:06:12,500 --> 00:06:14,450
一个连续的数据子集。

182
00:06:14,450 --> 00:06:15,160
structure.

183
00:06:15,830 --> 00:06:17,750
变量b的类型读作

184
00:06:17,750 --> 00:06:19,760
元素类型为i32的slice。

185
00:06:19,760 --> 00:06:20,350


186
00:06:21,260 --> 00:06:23,420
这个例子中，b指向a中

187
00:06:23,420 --> 00:06:25,460
的索引0（包括）到

188
00:06:25,460 --> 00:06:27,670
索引1（不包括）的部分，

189
00:06:27,670 --> 00:06:29,690
具体来说就是

190
00:06:29,690 --> 00:06:31,120
元素100。

191
00:06:32,279 --> 00:06:34,330
一种特殊的切片是字符串切片， 

192
00:06:34,330 --> 00:06:36,130
写做“&str”。

193
00:06:36,130 --> 00:06:37,320


194
00:06:37,560 --> 00:06:39,600
通过使用字符串字面量，是一种常见的

195
00:06:39,600 --> 00:06:41,210
创建字符串切片的方式。

196
00:06:41,580 --> 00:06:43,770
我们讲将在下一章更深入地

197
00:06:43,770 --> 00:06:45,330
探讨字符串切片和

198
00:06:45,330 --> 00:06:46,670
普通的切片。

199
00:06:48,000 --> 00:06:48,930
在本节中，

200
00:06:48,930 --> 00:06:51,000
我们介绍了Rust中各种各样的

201
00:06:51,000 --> 00:06:52,370
原始数据类型。

202
00:06:52,980 --> 00:06:54,060
在之后的课程里，

203
00:06:54,060 --> 00:06:56,040
我们还要介绍使用结构体和

204
00:06:56,040 --> 00:06:58,320
枚举来构建复杂类型。

205
00:06:58,320 --> 00:06:59,230


