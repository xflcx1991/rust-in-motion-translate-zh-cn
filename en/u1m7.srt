1
00:00:02,390 --> 00:00:09,280
Enums, or enumerations, are a way to express that a value can be one out of a finite set of possible values,

2
00:00:09,740 --> 00:00:12,110
such as one of the suits in a deck of playing cards.

3
00:00:12,960 --> 00:00:17,760
Enums are one of the ways of defining custom types in Rust. Structs are the other,

4
00:00:17,770 --> 00:00:19,850
and we'll be covering structs in the next module.

5
00:00:21,690 --> 00:00:25,350
We're going to be using some of the primitive data types we covered in module 4,

6
00:00:25,940 --> 00:00:27,190
and we'll show how enums work

7
00:00:27,200 --> 00:00:34,410
especially well with the match expression that we covered in module 6 about control flow.

8
00:00:34,760 --> 00:00:35,080
In this module, first,

9
00:00:35,080 --> 00:00:37,550
we'll talk a bit more about when enums are useful.

10
00:00:38,490 --> 00:00:42,010
Then, we'll look at the syntax for defining and using enums in Rust.

11
00:00:43,240 --> 00:00:46,040
We'll see how we can define enum variants that hold data,

12
00:00:46,310 --> 00:00:50,950
and we'll wrap up the module by looking at some examples of enums used with match expressions.

13
00:00:53,040 --> 00:00:55,580
Let's start with an example of when enums are useful.

14
00:00:57,240 --> 00:01:01,360
Let's say we're writing a program having to do with ice hockey. In hockey,

15
00:01:01,440 --> 00:01:02,430
there are different positions

16
00:01:02,430 --> 00:01:06,170
a player can play: center, wing, defense,

17
00:01:06,320 --> 00:01:06,900
or goalie.

18
00:01:08,840 --> 00:01:16,810
There are two aspects of this property of a player that make this a good case to model with an enum.

19
00:01:16,820 --> 00:01:17,010
First, a

20
00:01:17,010 --> 00:01:22,320
player can only be in one of these positions at a time. While players may change positions,

21
00:01:22,610 --> 00:01:26,050
they're not going to be in the goal and playing center at the same moment.

22
00:01:28,240 --> 00:01:28,890
Second,

23
00:01:29,070 --> 00:01:32,890
we can list all the possibilities for the values of a position in ice hockey.

24
00:01:33,640 --> 00:01:35,650
There's a finite number of possible values,

25
00:01:35,840 --> 00:01:36,850
and they don't change.

26
00:01:37,540 --> 00:01:41,650
Our hockey program won't need to allow users to define new hockey positions.

27
00:01:43,640 --> 00:01:45,650
Now that we've got a use case for an enum,

28
00:01:46,240 --> 00:01:47,280
let's see how to define it

29
00:01:47,290 --> 00:01:47,940
in Rust code.

30
00:01:49,940 --> 00:01:53,680
We start with the enum keyword and then choose a name for the whole set.

31
00:01:53,930 --> 00:01:54,710
In this case,

32
00:01:54,740 --> 00:01:56,450
we're going to choose HockeyPosition.

33
00:01:57,590 --> 00:02:01,970
Then, we put curly brackets and a comma-separated list of the possible values

34
00:02:01,970 --> 00:02:02,340
the

35
00:02:02,340 --> 00:02:02,560
enum

36
00:02:02,560 --> 00:02:05,150
can have. These are called the enum's variants.

37
00:02:06,180 --> 00:02:06,990
In this case,

38
00:02:07,120 --> 00:02:13,250
we have variants for Center, Wing, Defense, and Goalie. Both enum names and

39
00:02:13,250 --> 00:02:13,390
enum

40
00:02:13,390 --> 00:02:16,350
variant names are in camel case in idiomatic Rust.

41
00:02:18,210 --> 00:02:20,230
We've got a HockeyPosition type defined;

42
00:02:20,350 --> 00:02:21,450
let's look at how to use it!

43
00:02:23,410 --> 00:02:31,350
We can set a variable to have the value of one of the enum's variants by specifying the name of the enum, then two colons, then the variant.

44
00:02:32,040 --> 00:02:35,550
The enum variants are namespaced beneath the overall enum type.

45
00:02:37,340 --> 00:02:41,050
We can also define a function to take a HockeyPosition as a parameter,

46
00:02:41,540 --> 00:02:45,550
and we can call that function and pass it a value of any of the enum's variants.

47
00:02:47,240 --> 00:02:48,840
This function doesn't do anything –

48
00:02:48,850 --> 00:02:50,450
we're just showing how the signature is written.

49
00:02:52,280 --> 00:02:52,870
Each enum

50
00:02:52,870 --> 00:02:55,750
variant can also be defined to hold additional data.

51
00:02:56,740 --> 00:02:59,710
This is different for enums in languages like Java and C,

52
00:02:59,740 --> 00:03:01,450
which can't hold additional data.

53
00:03:03,640 --> 00:03:07,950
Here's an enum that represents different kinds of clocks our program supports.

54
00:03:08,540 --> 00:03:10,900
Sundials only really have an hour value.

55
00:03:12,140 --> 00:03:15,550
The digital clocks we support only have hours and minutes.

56
00:03:16,070 --> 00:03:24,350
The analog clocks we support have an hour hand, a minute hand, and a second hand.

57
00:03:24,760 --> 00:03:27,470
Variants can hold multiple pieces of data. The parentheses are like a tuple.

58
00:03:27,470 --> 00:03:31,790
Enum variants can also have named fields and look like a struct –  we'll be covering

59
00:03:31,790 --> 00:03:33,150
structs in the next module.

60
00:03:35,140 --> 00:03:35,750
Finally,

61
00:03:36,210 --> 00:03:39,150
let's see how enums and match expressions work well together.

62
00:03:40,240 --> 00:03:41,750
Taking our clock example,

63
00:03:42,280 --> 00:03:44,760
let's write a function to print out the time in words,

64
00:03:44,770 --> 00:03:46,400
no matter what kind of clock we have.

65
00:03:47,370 --> 00:03:49,550
This function has a parameter of a clock value.

66
00:03:49,550 --> 00:03:54,330
In the function, we'll match on that clock value and do something different

67
00:03:54,340 --> 00:03:59,350
based on which variant we have. Within each pattern of the match expression,

68
00:03:59,740 --> 00:04:02,350
we can destructure the values each variant holds.

69
00:04:02,840 --> 00:04:03,650
For example,

70
00:04:03,660 --> 00:04:04,850
in the Analog pattern,

71
00:04:05,340 --> 00:04:07,640
we're creating the new variables – hours,

72
00:04:07,710 --> 00:04:14,950
minutes, and seconds – that matched the three u8 values held in that variant. In the code that goes with that pattern,

73
00:04:15,340 --> 00:04:16,850
we can use those variables.

74
00:04:20,840 --> 00:04:21,750
This code prints

75
00:04:22,480 --> 00:04:25,650
It is 25 minutes and 45 seconds past 9 o'clock.

76
00:04:28,100 --> 00:04:32,390
Enums are great for defining types that can be one of a possible set of values.

77
00:04:33,340 --> 00:04:35,250
They can optionally hold extra data,

78
00:04:35,640 --> 00:04:43,150
and we can use match expressions to make decisions based on which variant we have, and use the patterns to destructure the values in the variants.

79
00:04:44,940 --> 00:04:45,490
Next,

80
00:04:45,670 --> 00:04:48,370
we'll talk about another way to define custom data types – structs.

